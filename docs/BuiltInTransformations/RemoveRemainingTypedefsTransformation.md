`RemoveRemainingTypedefsTransformation`
===================================================================================================

<small>\[[Transformation Source](../../Biohazrd.CSharp/#Transformations/RemoveRemainingTypedefsTransformation.cs)\]</small>

This transformation removes any and all `TranslatedTypedef` declarations present in the entire library.

It is named "remaining" because it is generally assumed you might manually replace certain typedefs in the library using your own custom transformations. For example, InfectedImGui's [`ImGuiEnumTransformation`](https://github.com/InfectedLibraries/InfectedImGui/blob/abaa9a27c59323919e4afa9f98c837cac1f619e5/InfectedImGui.Generator/%23Transformations/ImGuiEnumTransformation.cs) uses information from typedefs to rewrite Dear ImGui's enums to feel more natural to use with modern languages.

## When this transformation is applicable

This transformation should generally always be used.

If you don't apply this transformation before running [`TypeReductionTransformation`](TypeReductionTransformation.md), typedefs will be reduced to type references to the `TranslatedTypedef` declaration rather than the `typedef`'s underlying type. Since the C# output generator doesn't handle `typedef`s (since they have no represnetation in C#) these references will fail to resolve at emit time and you will have errors where you otherwise might not have had them.

## Example

Given the following C++ example:

```cpp
typedef int MyInteger;

MyInteger GetFavoriteNumber();
```

Biohazrd's translation stage will output the following declaration tree:

```
TranslatedTypedef MyInteger -> `int`
TranslatedFunction GetFavoriteNumber -> `MyInteger`
```

If we tried to output the translated library now (after some basic type reduction but without verification) we'd get the following unusable output:

```csharp
// This file was automatically generated by Biohazrd and should not be modified by hand!
using System.Runtime.InteropServices;

/* Failed to emit TranslatedTypedef MyInteger: Typedefs cannot be directly represented in C#. */
// typedef 'System.Int32' 'MyInteger'

[DllImport("Example.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetFavoriteNumber@@YAHXZ", ExactSpelling = true)]
public static extern MyInteger GetFavoriteNumber();
```

Along with the unusable output, you get the following diagnostic upon emit:

> â›” Error: Could not emit TranslatedTypedef MyInteger @ TranslatedLibrary: Typedefs cannot be directly represented in C#.

Note that `GetFavoriteNumber` returns `MyInteger`, which was never defined due to the emit failure. So this C# code will fail to compile.

Applying the transformation removes this untranslatable `typedef`:

```
TranslatedFunction GetFavoriteNumber -> `MyInteger`
```

Which results in usable C# output:

```csharp
// This file was automatically generated by Biohazrd and should not be modified by hand!
using System.Runtime.InteropServices;

[DllImport("Example.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetFavoriteNumber@@YAHXZ", ExactSpelling = true)]
public static extern int GetFavoriteNumber();
```

Note that `MyInteger` was reduced to `int`. If this isn't appopriate for your library, you would need to apply a custom transformation before `RemoveRemainingTypedefsTransformation` to translate the typedef into something else.

If you're wondering why the declaration tree still referened `MyInteger`, that's because that declaration tree is from before type reduction. After type reduction it looks like this:

```
TranslatedFunction GetFavoriteNumber -> System.Int32
```
